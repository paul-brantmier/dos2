<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Remote Click Stream (Host or Viewer)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, Arial; margin: 20px; }
    .row { display: flex; gap: 16px; flex-wrap: wrap; }
    fieldset { min-width: 280px; }
    video { width: min(100%, 960px); max-height: 70vh; background:#111; }
    .warn { color: #b00; font-weight: 600; }
    .ok { color: #0a0; }
    #overlay {
      position: relative; display: inline-block;
    }
    #pinwatermark {
      position:absolute; top:8px; right:8px; padding:4px 8px;
      background: rgba(0,0,0,.5); color:#fff; font-size:12px; border-radius:6px;
    }
  </style>
</head>
<body>
  <h1>Remote Click Stream</h1>
  <p class="warn">⚠️ Powerful feature. Share control only with people you trust. Use a PIN.</p>

  <div class="row">
    <fieldset>
      <legend>Session</legend>
      <label>Signaling URL:
        <input id="wsUrl" size="36" value="wss://58d1b821d90b.ngrok-free.app/signaling" />
      </label><br><br>
      <label>Session ID:
        <input id="sessionId" value="dos2" placeholder="e.g. my-game" />
      </label><br><br>
      <label>PIN:
        <input id="pin" value="123456" placeholder="123456" />
      </label><br><br>
      <label><input id="allowControl" type="checkbox" /> Allow remote clicks</label><br><br>
      <button id="hostBtn">Start Hosting</button>
      <button id="viewBtn">Join as Viewer</button>
      <div id="status"></div>
    </fieldset>

    <fieldset>
      <legend>Host Controls</legend>
      <button id="approveToggle" disabled>Require Approval: OFF</button>
      <button id="endBtn" disabled>End Session</button>
      <div>Local agent: <span id="agentStatus">unknown</span></div>
    </fieldset>
  </div>

  <div id="overlay">
    <video id="video" playsinline autoplay muted></video>
    <div id="pinwatermark"></div>
  </div>

<script>
(async () => {
  const wsUrl = document.getElementById('wsUrl');
  const sessionIdEl = document.getElementById('sessionId');
  const pinEl = document.getElementById('pin');
  const hostBtn = document.getElementById('hostBtn');
  const viewBtn = document.getElementById('viewBtn');
  const statusEl = document.getElementById('status');
  const video = document.getElementById('video');
  const allowControlEl = document.getElementById('allowControl');
  const pinWatermark = document.getElementById('pinwatermark');
  const approveToggle = document.getElementById('approveToggle');
  const endBtn = document.getElementById('endBtn');
  const agentStatus = document.getElementById('agentStatus');

  let role = null;          // 'host' or 'viewer'
  let ws = null;            // signaling socket
  let pc = null;            // RTCPeerConnection
  let dataChannel = null;   // WebRTC data channel
  let requireApproval = false;

  // Basic helper UI
  const setStatus = (msg, ok=false) => {
    statusEl.textContent = msg;
    statusEl.className = ok ? 'ok' : 'warn';
  };

  // Test local agent availability (host only)
  async function pingAgent() {
    try {
      const r = await fetch('http://127.0.0.1:17345/health', { method:'GET' });
      if (r.ok) { agentStatus.textContent = 'online'; agentStatus.className = 'ok'; }
      else { agentStatus.textContent = 'offline'; agentStatus.className = 'warn'; }
    } catch {
      agentStatus.textContent = 'offline'; agentStatus.className = 'warn';
    }
  }

  // WebSocket signaling wrapper
  function openSignaling() {
  return new Promise((resolve, reject) => {
    ws = new WebSocket(wsUrl.value);

    ws.onopen  = () => resolve(ws);
    ws.onerror = (e) => reject(e);

    ws.onmessage = async (ev) => {
      const msg = JSON.parse(ev.data);
      // console.log('signal:', msg.type); // optional debug

      if (msg.type === 'offer' && role === 'viewer') {
        await pc.setRemoteDescription(msg.sdp);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        ws.send(JSON.stringify({
          type: 'answer',
          sessionId: sessionIdEl.value,
          sdp: answer
        }));

      } else if (msg.type === 'answer' && role === 'host') {
        await pc.setRemoteDescription(msg.sdp);

      } else if (msg.type === 'ice') {
        try { await pc.addIceCandidate(msg.candidate); } catch {}

      } else if (msg.type === 'viewer-joined' && role === 'host') {
        // NEW: send a fresh offer whenever a viewer connects
        console.log('Viewer joined → sending new offer…');
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        ws.send(JSON.stringify({
          type: 'offer',
          sessionId: sessionIdEl.value,
          pin: pinEl.value,
          sdp: offer
        }));
      }
    };
  });
}

  function createPeerConnection() {
    const conf = { iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }] };
    pc = new RTCPeerConnection(conf);

    pc.onicecandidate = e => {
      if (e.candidate) {
        ws.send(JSON.stringify({ type:'ice', sessionId: sessionIdEl.value, candidate: e.candidate }));
      }
    };
    pc.onconnectionstatechange = () => {
      if (pc.connectionState === 'connected') setStatus('WebRTC: connected', true);
    };

    pc.ontrack = (ev) => { // viewer receives video
      video.srcObject = ev.streams[0];
    };

    pc.ondatachannel = (ev) => { // host creates; viewer receives
      dataChannel = ev.channel;
      dataChannel.onmessage = (e) => {
        // Host receives viewer click events here (normalized coords)
        if (role === 'host') onRemoteClick(JSON.parse(e.data));
      };
    };
  }

  async function startHost() {
    role = 'host';
    await openSignaling();
    createPeerConnection();

    // Host creates data channel
    dataChannel = pc.createDataChannel('control');
    dataChannel.onopen = () => setStatus('Control channel open. Viewers can send clicks if allowed.', true);

    // Ask to share a specific window/application
    const stream = await navigator.mediaDevices.getDisplayMedia({ video: { cursor: 'always' }, audio: false });
    stream.getTracks().forEach(t => pc.addTrack(t, stream));
    video.srcObject = stream; // local preview on host too

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    ws.send(JSON.stringify({
      type: 'offer',
      sessionId: sessionIdEl.value,
      pin: pinEl.value,
      sdp: offer
    }));

    approveToggle.disabled = false;
    endBtn.disabled = true;
    pinWatermark.textContent = `Session: ${sessionIdEl.value} • PIN: ${pinEl.value}`;
    setInterval(pingAgent, 2500);
  }

  async function startViewer() {
    role = 'viewer';
    await openSignaling();
    createPeerConnection();

    ws.send(JSON.stringify({ type:'join', sessionId: sessionIdEl.value, pin: pinEl.value }));
    setStatus('Joined. Waiting for host stream...', true);
  }

  // Viewer: capture clicks, send normalized coords over data channel
  video.addEventListener('click', (ev) => {
    if (role !== 'viewer') return;
    if (!dataChannel || dataChannel.readyState !== 'open') return;
    const rect = video.getBoundingClientRect();
    const nx = (ev.clientX - rect.left) / rect.width;
    const ny = (ev.clientY - rect.top) / rect.height;
    dataChannel.send(JSON.stringify({ kind:'click', nx, ny, ts: Date.now() }));
  });

  // Host: receive click, optionally require approval, then forward to local agent
  async function onRemoteClick(evt) {
    if (!allowControlEl.checked) return;
    if (requireApproval) {
      const ok = confirm(`Execute remote click at ${(evt.nx*100).toFixed(1)}%, ${(evt.ny*100).toFixed(1)}% ?`);
      if (!ok) return;
    }
    try {
      const r = await fetch('http://127.0.0.1:17345/click', {
        method:'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify({
          nx: evt.nx, ny: evt.ny,
          sessionId: sessionIdEl.value,
          pin: pinEl.value
        })
      });
      if (!r.ok) console.warn('Local agent rejected click');
    } catch (e) {
      console.error('Local agent not reachable', e);
    }
  }

  // UI wiring
  hostBtn.onclick = () => startHost().catch(e => setStatus(`Host error: ${e.message}`));
  viewBtn.onclick = () => startViewer().catch(e => setStatus(`Viewer error: ${e.message}`));
  approveToggle.onclick = () => {
    requireApproval = !requireApproval;
    approveToggle.textContent = `Require Approval: ${requireApproval ? 'ON' : 'OFF'}`;
  };
  endBtn.onclick = () => { pc?.close(); ws?.close(); location.reload(); };
})();
</script>
</body>
</html>



